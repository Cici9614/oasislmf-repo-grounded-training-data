{"id": "design_auto_0048", "task_type": "design", "instruction": "设计题：假设需要让 `GenerateComputationSettingsJsonSchema` 支持一种新的输入数据格式/字段，但要求不破坏现有调用方。请基于当前代码结构给出可实施的扩展方案，并指出可能修改的文件与位置。", "context": [{"source_type": "code", "path": "oasislmf/cli/model.py", "content": "# File: oasislmf/cli/model.py\n# class: GenerateComputationSettingsJsonSchema (lines 122-127)\n\nclass GenerateComputationSettingsJsonSchema(OasisComputationCommand):\n    \"\"\"\n    Generate a json schema to validate the computation settings part of oed settings\n    \"\"\"\n    formatter_class = RawDescriptionHelpFormatter\n    computation_name = 'GenerateComputationSettingsJsonSchema'\n\n\"\"\"Docstring (excerpt)\"\"\"\nGenerate a json schema to validate the computation settings part of oed settings"}], "reasoning_trace": [{"step": 1, "goal": "确认当前组件职责与边界", "evidence_ref": ["oasislmf/cli/model.py"], "intermediate_conclusion": "`GenerateComputationSettingsJsonSchema` 在 `oasislmf/cli/model.py` 中承担特定处理职责，应在其边界内扩展。"}, {"step": 2, "goal": "提出兼容性优先的扩展策略", "evidence_ref": ["oasislmf/cli/model.py"], "intermediate_conclusion": "通过适配层/解析函数新增支持，避免破坏现有契约与调用链。"}], "output": "基于 `oasislmf/cli/model.py` 中 `GenerateComputationSettingsJsonSchema` 的职责（见 docstring 与实现片段），在保持向后兼容的前提下可采用：\n1) 接口兼容：保留现有入参/返回契约，在内部引入“适配层/解析函数”处理新格式。\n2) 扩展点隔离：将新格式解析逻辑封装为独立函数/类，避免把分支逻辑散落在主流程。\n3) 渐进式切换：为新格式增加单测与示例；必要时在文档中声明支持范围。\n4) 修改位置：优先在 `oasislmf/cli/model.py` 的 `GenerateComputationSettingsJsonSchema` 定义附近（约第 122 行）扩展解析与分派逻辑；如存在调用链入口（CLI/管线），同步更新其输入校验与参数说明。\n", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_DESIGN", "difficulty": "medium", "language": "zh"}}
{"id": "qa_auto_0155", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/utils/log_config.py` 文件里的 `validate_config` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/utils/log_config.py", "content": "# File: oasislmf/utils/log_config.py\n# function: validate_config (lines 212-249)\n\n    def validate_config(self) -> List[str]:\n        \"\"\"\n        Validate logging configuration and return any issues.\n\n        Returns:\n            List of warning messages about configuration issues\n        \"\"\"\n        warnings = []\n        logging_config = self.config.get(\"logging\", {})\n\n        # Validate main log level\n        level = logging_config.get(\"level\")\n        if level:\n            try:\n                self._parse_level(level)\n            except ValueError as e:\n                warnings.append(f\"Invalid log level in config: {e}\")\n\n        # Validate ods_tools level\n        ods_level = logging_config.get(\"ods_tools_level\")\n        if ods_level:\n            try:\n                self._parse_level(ods_level)\n            except ValueError as e:\n                warnings.append(f\"Invalid ods_tools log level in config: {e}\")\n\n        # Validate format (lenient - custom format strings are allowed)\n        format_name = logging_config.get(\"format\")\n        if format_name and format_name not in self.FORMAT_TEMPLATES:\n            # Only warn if it doesn't look like a format string\n            if not (\"%(message)s\" in str(format_name) or \"%(\" in str(format_name)):\n                available = \", \".join(self.get_available_formats())\n                warnings.append(\n                    f\"Format '{format_name}' may not be a valid format template. \"\n                    f\"Available templates: {available}\"\n                )\n\n        return warnings\n\n\"\"\"Docstring (excerpt)\"\"\"\nValidate logging configuration and return any issues.\n\nReturns:\n    List of warning messages about configuration issues"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/utils/log_config.py"], "intermediate_conclusion": "在 `oasislmf/utils/log_config.py` 中找到 `validate_config` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/utils/log_config.py"], "intermediate_conclusion": "docstring 的首句可作为 `validate_config` 职责的高置信摘要。"}], "output": "`validate_config`（位于 `oasislmf/utils/log_config.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Validate logging configuration and return any issues.\n\n证据：该定义出现在文件 `oasislmf/utils/log_config.py` 的第 212 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0130", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/utils/profiles.py` 文件里的 `get_grouped_fm_profile_by_level_and_term_group` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/utils/profiles.py", "content": "# File: oasislmf/utils/profiles.py\n# function: get_grouped_fm_profile_by_level_and_term_group (lines 44-87)\n\ndef get_grouped_fm_profile_by_level_and_term_group(\n    exposure_profile=get_default_exposure_profile(),\n    accounts_profile=get_default_accounts_profile(),\n    grouped_profile_by_level=None\n):\n    \"\"\"\n    Get the grouped exposure + accounts profile - this describes the\n    financial terms found in the source exposure and accounts files,\n    which are for the following FM levels: site coverage (# 1),\n    site pd (# 2), site all (# 3), cond. all (# 6), policy all (# 9),\n    policy layer (# 10).  It also describes the OED hierarchy terms\n    present in the exposure and accounts files, namely portfolio num.,\n    acc. num., loc. num., and cond. num.\n    \"\"\"\n    grouped = grouped_profile_by_level or get_grouped_fm_profile_by_level(exposure_profile, accounts_profile)\n\n    grouped_fm_term_types = OrderedDict({\n        'deductible': FM_TERMS['deductible']['id'],\n        'deductiblecode': FM_TERMS['deductible code']['id'],\n        'deductibletype': FM_TERMS['deductible type']['id'],\n        'deductiblemin': FM_TERMS['min deductible']['id'],\n        'deductiblemax': FM_TERMS['max deductible']['id'],\n        'limit': FM_TERMS['limit']['id'],\n        'limitcode': FM_TERMS['limit code']['id'],\n        'limittype': FM_TERMS['limit type']['id'],\n        'share': FM_TERMS['share']['id']\n    })\n    profile = OrderedDict({\n        level: OrderedDict({\n            FMTermGroupID: OrderedDict({\n                (grouped_fm_term_types.get(term['FMTermType'].lower()) or term['FMTermType'].lower()): term for term in TermGroup\n            }) for FMTermGroupID, TermGroup in groupby(sorted(grouped[level].values(),\n                                                              key=lambda term: term['FMTermGroupID']),\n                                                       key=lambda term: term['FMTermGroupID'])\n        }) for level in sorted(grouped)\n    })\n\n    if not profile:\n        raise OasisException(\n            'Unable to get a unified FM profile by level and term group. '\n            'Canonical loc. and/or acc. profiles are possibly missing FM term information: '\n            'FM term definitions for TIV, deductibles, limit, and/or share.'\n        )\n    return profile\n\n\"\"\"Docstring (excerpt)\"\"\"\nGet the grouped exposure + accounts profile - this describes the\nfinancial terms found in the source exposure and accounts files,\nwhich are for the following FM levels: site coverage (# 1),\nsite pd (# 2), site all (# 3), cond. all (# 6), policy all (# 9),\npolicy layer (# 10).  It also describes the OED hierarchy terms\npresent in the exposure and accounts files, namely portfolio num.,\nacc. num., loc. num., and cond. num."}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/utils/profiles.py"], "intermediate_conclusion": "在 `oasislmf/utils/profiles.py` 中找到 `get_grouped_fm_profile_by_level_and_term_group` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/utils/profiles.py"], "intermediate_conclusion": "docstring 的首句可作为 `get_grouped_fm_profile_by_level_and_term_group` 职责的高置信摘要。"}], "output": "`get_grouped_fm_profile_by_level_and_term_group`（位于 `oasislmf/utils/profiles.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Get the grouped exposure + accounts profile - this describes the\n\n证据：该定义出现在文件 `oasislmf/utils/profiles.py` 的第 44 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0060", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/pytools/common/event_stream.py` 文件里的 `read_event` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/pytools/common/event_stream.py", "content": "# File: oasislmf/pytools/common/event_stream.py\n# function: read_event (lines 322-371)\n\n    def read_event(self, stream_in, main_selector, stream_selector, mv, byte_mv, cursor, valid_buff, file_idx):\n        \"\"\"\n        read one event from stream_in\n        close and remove the stream from main_selector when all is read\n        Args:\n            stream_in: stream to read\n            main_selector: selector that contain all the streams\n            stream_selector:  this stream selector\n            mv: buffer memoryview\n            byte_mv: numpy byte view of the buffer\n            cursor: current cursor of the memory view\n            valid_buff: valid data in memory view\n            file_idx: file index\n\n        Returns:\n            event_id, cursor, valid_buff\n        \"\"\"\n        event_id = 0\n        item_id = 0\n        try:\n            while True:\n                if valid_buff < PIPE_CAPACITY:\n                    stream_selector.select()\n                    len_read = stream_in.readinto1(mv[valid_buff:])\n                    valid_buff += len_read\n\n                    if len_read == 0:\n                        stream_selector.close()\n                        main_selector.unregister(stream_in)\n                        if event_id:\n                            self.item_exit()\n                            return event_id, cursor, valid_buff\n\n                        break\n                cursor, event_id, item_id, yield_event = self.read_buffer(byte_mv, cursor, valid_buff, event_id, item_id, file_idx=file_idx)\n\n                if yield_event:\n                    if 2 * cursor > valid_buff:\n                        mv[:valid_buff - cursor] = mv[cursor: valid_buff]\n                        valid_buff -= cursor\n                        cursor = 0\n                    return event_id, cursor, valid_buff\n                else:\n                    mv[:valid_buff - cursor] = mv[cursor: valid_buff]\n                    valid_buff -= cursor\n                    cursor = 0\n\n        except Exception as e:\n            self.logger.error(str(e))\n            raise OasisStreamException(\"Error reading stream\", e)\n\n\"\"\"Docstring (excerpt)\"\"\"\nread one event from stream_in\nclose and remove the stream from main_selector when all is read\nArgs:\n    stream_in: stream to read\n    main_selector: selector that contain all the streams\n    stream_selector:  this stream selector\n    mv: buffer memoryview\n    byte_mv: numpy byte view of the buffer\n    cursor: current cursor of the memory view\n    valid_buff: valid data in memory view\n    file_idx: file index\n\nReturns:\n    event_id, cursor, valid_buff"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/pytools/common/event_stream.py"], "intermediate_conclusion": "在 `oasislmf/pytools/common/event_stream.py` 中找到 `read_event` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/pytools/common/event_stream.py"], "intermediate_conclusion": "docstring 的首句可作为 `read_event` 职责的高置信摘要。"}], "output": "`read_event`（位于 `oasislmf/pytools/common/event_stream.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：read one event from stream_in\n\n证据：该定义出现在文件 `oasislmf/pytools/common/event_stream.py` 的第 322 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "hazard", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0056", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/pytools/common/event_stream.py` 文件里的 `mv_write` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/pytools/common/event_stream.py", "content": "# File: oasislmf/pytools/common/event_stream.py\n# function: mv_write (lines 126-140)\n\ndef mv_write(byte_mv, cursor, _dtype, itemsize, value) -> int:\n    \"\"\"\n    load an object into the numpy byte view at index cursor, return the index of the end of the object\n    Args:\n        byte_mv: numpy byte view\n        cursor: index of where the object start\n        _dtype: data type of the object\n        itemsize: size of the data type\n        value: value to write\n\n    Returns:\n        end of object index\n    \"\"\"\n    byte_mv[cursor:cursor + itemsize].view(_dtype)[0] = value\n    return cursor + itemsize\n\n\"\"\"Docstring (excerpt)\"\"\"\nload an object into the numpy byte view at index cursor, return the index of the end of the object\nArgs:\n    byte_mv: numpy byte view\n    cursor: index of where the object start\n    _dtype: data type of the object\n    itemsize: size of the data type\n    value: value to write\n\nReturns:\n    end of object index"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/pytools/common/event_stream.py"], "intermediate_conclusion": "在 `oasislmf/pytools/common/event_stream.py` 中找到 `mv_write` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/pytools/common/event_stream.py"], "intermediate_conclusion": "docstring 的首句可作为 `mv_write` 职责的高置信摘要。"}], "output": "`mv_write`（位于 `oasislmf/pytools/common/event_stream.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：load an object into the numpy byte view at index cursor, return the index of the end of the object\n\n证据：该定义出现在文件 `oasislmf/pytools/common/event_stream.py` 的第 126 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "hazard", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0024", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/lookup/factory.py` 文件里的 `KeyServerFactory` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/lookup/factory.py", "content": "# File: oasislmf/lookup/factory.py\n# class: KeyServerFactory (lines 99-217)\n\nclass KeyServerFactory(object):\n    \"\"\"\n    A factory class to create the Keys Server that will be use to generate the keys files\n    All Key Server must implement the interface defined in lookup.interface.KeyServerInterface\n\n    Oasis provides a built-in Key Server that manage the generation of the key files from the key provided by\n    a built-in or a custom Key Lookup.\n\n    The factory now return a KeyServer object and not a KeyLookup.\n    The parameter to pass has also been simplified\n    usage of all the below parameter are now deprecated\n      - complex_lookup_config_fp => pass the path to your complex lookup config directly in lookup_config_fg\n      - lookup_module_path => set as key 'lookup_module_path' in the lookup config\n      - model_keys_data_path => set as key 'keys_data_path' in the lookup config\n      - model_version_file_path => set the model information ('supplier_id', 'model_id', 'model_version') directly\n        into the config\n    \"\"\"\n\n    @classmethod\n    def get_config(cls, config_fp):\n        return as_path(os.path.dirname(config_fp), 'config_fp'), get_json(config_fp)\n\n    @classmethod\n    def get_model_info(cls, model_version_file_path):\n        \"\"\"\n        Get model information from the model version file.\n        \"\"\"\n        model_version_file_path = as_path(model_version_file_path, 'model_version_file_path', preexists=True, null_is_valid=False)\n\n        with open(model_version_file_path, 'r', encoding='utf-8') as f:\n            return next(csv.DictReader(\n                f, fieldnames=['supplier_id', 'model_id', 'model_version']\n            ))\n\n    @classmethod\n    def update_deprecated_args(cls, config_dir, config,\n                               complex_lookup_config_fp, model_keys_data_path, model_version_file_path, lookup_module_path):\n        if (complex_lookup_config_fp or model_keys_data_path or model_version_file_path or lookup_module_path):\n            warnings.warn('usage of complex_lookup_config_fp, model_keys_data_path, '\n                          'model_version_file_path and lookup_module_path is now deprecated'\n                          'those variables now need to be set in lookup config see (key server documentation)')\n\n        if complex_lookup_config_fp and not isinstance(complex_lookup_config_fp, dict):\n            config_dir, config = cls.get_config(complex_lookup_config_fp)\n\n        if model_keys_data_path:\n            config['keys_data_path'] = as_path(model_keys_data_path, 'model_keys_data_path', preexists=True)\n\n        if model_version_file_path:\n            config['model'] = cls.get_model_info(model_version_file_path)\n\n        if lookup_module_path:\n            config['lookup_module_path'] = lookup_module_path\n\n        return config_dir, config\n\n    @classmethod\n    def create(\n            cls,\n            model_keys_data_path=None,\n            model_version_file_path=None,\n            lookup_module_path=None,\n            lookup_config=None,\n            lookup_config_json=None,\n            lookup_config_fp=None,\n            complex_lookup_config_fp=None,  # this is now use to pass the run settings if there is no complex_lookup_config_fp\n            user_data_dir=None,\n            output_directory=None,\n    ):\n        \"\"\"\n        Creates a keys lookup class instance for the given model and supplier -\n        local file paths are required for the model keys data folder, the model\n        version file and the Git repository for the model keys server. Returns a\n        pair ``(model_info, klc)``, where ``model_info`` is a dictionary holding\n        model information from the model version file and `klc` is the lookup\n        service class instance for the model.\n        \"\"\"\n        if lookup_config:\n            config_dir = '.'\n            config = lookup_config\n\n\"\"\"Docstring (excerpt)\"\"\"\nA factory class to create the Keys Server that will be use to generate the keys files\nAll Key Server must implement the interface defined in lookup.interface.KeyServerInterface\n\nOasis provides a built-in Key Server that manage the generation of the key files from the key provided by\na built-in or a custom Key Lookup.\n\nThe factory now return a KeyServer object and not a KeyLookup.\nThe parameter to pass has also been simplified\nusage of all the below parameter are now deprecated\n  - complex_lookup_config_fp => pass the path to your complex lookup config directly in lookup_config_fg\n  - lookup_module_path => set as key 'lookup_module_path' in the lookup config\n  - model_keys_data_path => set as key 'keys_data_path' in the lookup config\n  - model_version_file_path => set the model information ('supplier_id', 'model_id', 'model_version') directly\n    into the config"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/lookup/factory.py"], "intermediate_conclusion": "在 `oasislmf/lookup/factory.py` 中找到 `KeyServerFactory` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/lookup/factory.py"], "intermediate_conclusion": "docstring 的首句可作为 `KeyServerFactory` 职责的高置信摘要。"}], "output": "`KeyServerFactory`（位于 `oasislmf/lookup/factory.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：A factory class to create the Keys Server that will be use to generate the keys files\n\n证据：该定义出现在文件 `oasislmf/lookup/factory.py` 的第 99 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0008", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/pytools/common/event_stream.py` 文件里的 `mv_read` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/pytools/common/event_stream.py", "content": "# File: oasislmf/pytools/common/event_stream.py\n# function: mv_read (lines 110-122)\n\ndef mv_read(byte_mv, cursor, _dtype, itemsize):\n    \"\"\"\n    read a certain dtype from numpy byte view starting at cursor, return the value and the index of the end of the object\n    Args:\n        byte_mv: numpy byte view\n        cursor: index of where the object start\n        _dtype: data type of the object\n        itemsize: size of the data type\n\n    Returns:\n        (object value, end of object index)\n    \"\"\"\n    return byte_mv[cursor:cursor + itemsize].view(_dtype)[0], cursor + itemsize\n\n\"\"\"Docstring (excerpt)\"\"\"\nread a certain dtype from numpy byte view starting at cursor, return the value and the index of the end of the object\nArgs:\n    byte_mv: numpy byte view\n    cursor: index of where the object start\n    _dtype: data type of the object\n    itemsize: size of the data type\n\nReturns:\n    (object value, end of object index)"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/pytools/common/event_stream.py"], "intermediate_conclusion": "在 `oasislmf/pytools/common/event_stream.py` 中找到 `mv_read` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/pytools/common/event_stream.py"], "intermediate_conclusion": "docstring 的首句可作为 `mv_read` 职责的高置信摘要。"}], "output": "`mv_read`（位于 `oasislmf/pytools/common/event_stream.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：read a certain dtype from numpy byte view starting at cursor, return the value and the index of the end of the object\n\n证据：该定义出现在文件 `oasislmf/pytools/common/event_stream.py` 的第 110 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "hazard", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0009", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/lookup/builtin.py` 文件里的 `build_geotiff` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/lookup/builtin.py", "content": "# File: oasislmf/lookup/builtin.py\n# function: build_geotiff (lines 859-907)\n\n    def build_geotiff(self, file_path, band_info):\n        \"\"\"\n\n        Args:\n            file_path: path to the geotiff file\n            band_info: a dict where keys are assigned column name, and values are dicts with\n                id is the id of the band in the tiff file\n                default is the(value for outside of range location\n        Returns:\n            function to assign band value to each corresponding lat lon\n        \"\"\"\n        if gdal is None:\n            raise OasisException(\n                \"##### gdal need to be installed to use geotiff !!!#####\\n\"\n                \"on ubuntu, first install gdal then run pip based on the installed version\\n\"\n                \"-> apt-get update && apt-get install -y gdal-bin\\n\"\n                \"-> gdalinfo --version\\n\"\n                \"-> pip install gdal==<version>\"\n            )\n\n        tiff_dataset = gdal.Open(self.to_abs_filepath(file_path), gdal.GA_ReadOnly)\n        inv_gt = gdal.InvGeoTransform(tiff_dataset.GetGeoTransform())\n\n        defaults = np.empty(len(band_info), dtype=tiff_dataset.GetVirtualMemArray().dtype)\n        usefull_array_idx = np.empty(len(band_info), dtype='int')\n        for i, (col_name, info) in enumerate(band_info.items()):\n            if not 1 <= info['id'] <= tiff_dataset.RasterCount:\n                raise OasisException(f\"band {col_name}, {info} has id outside of [1-{tiff_dataset.RasterCount}]\")\n            idx = info['id'] - 1\n            usefull_array_idx[i] = idx\n            defaults[idx] = info['default']\n\n        def geotiff_lookup(locations):\n            tiff_array = tiff_dataset.GetVirtualMemArray()\n            if len(tiff_array.shape) == 2:\n                tiff_array = tiff_array.reshape((tiff_array.shape[0], tiff_array.shape[1], 1))\n            res = np.empty((len(locations), len(band_info)), dtype=tiff_array.dtype)\n            jit_gda_loc_to_val(tiff_array,\n                               inv_gt,\n                               locations['longitude'].to_numpy(),\n                               locations['latitude'].to_numpy(),\n                               usefull_array_idx,\n                               defaults,\n                               res)\n            for col_i, col_name in enumerate(band_info.keys()):\n                locations[col_name] = res[:, col_i]\n            return locations\n\n        return geotiff_lookup\n\n\"\"\"Docstring (excerpt)\"\"\"\nArgs:\n    file_path: path to the geotiff file\n    band_info: a dict where keys are assigned column name, and values are dicts with\n        id is the id of the band in the tiff file\n        default is the(value for outside of range location\nReturns:\n    function to assign band value to each corresponding lat lon"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/lookup/builtin.py"], "intermediate_conclusion": "在 `oasislmf/lookup/builtin.py` 中找到 `build_geotiff` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/lookup/builtin.py"], "intermediate_conclusion": "docstring 的首句可作为 `build_geotiff` 职责的高置信摘要。"}], "output": "`build_geotiff`（位于 `oasislmf/lookup/builtin.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Args:\n\n证据：该定义出现在文件 `oasislmf/lookup/builtin.py` 的第 859 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0109", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/preparation/summaries.py` 文件里的 `write_summary_levels` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/preparation/summaries.py", "content": "# File: oasislmf/preparation/summaries.py\n# function: write_summary_levels (lines 248-310)\n\ndef write_summary_levels(exposure_df, accounts_df, exposure_data, target_dir):\n    '''\n    Json file with list Available / Recommended columns for use in the summary reporting\n\n    Available: Columns which exists in input files and has at least one non-zero / NaN value\n    Recommended: Columns which are available + also in the list of `useful` groupings SUMMARY_LEVEL_LOC\n\n    {\n        'GUL': {\n            'available': ['AccNumber',\n                         'LocNumber',\n                         'istenant',\n                         'buildingid',\n                         'countrycode',\n                         'latitude',\n                         'longitude',\n                         'streetaddress',\n                         'postalcode',\n                         'occupancycode',\n                         'constructioncode',\n                         'locperilscovered',\n                         'BuildingTIV',\n                         'ContentsTIV',\n                         'BITIV',\n                         'PortNumber'],\n\n        'IL': {\n                ... etc ...\n        }\n    }\n    '''\n    # Manage internal columns, (Non-OED exposure input)\n    int_excluded_cols = ['loc_id', SOURCE_IDX['loc']]\n    desc_non_oed = 'Not an OED field'\n    int_oasis_cols = {\n        'coverage_type_id': 'Oasis coverage type',\n        'peril_id': 'OED peril code',\n        'coverage_id': 'Oasis coverage identifier',\n    }\n\n    # GUL perspective (loc columns only)\n    l_col_list = (exposure_df.drop(columns=['peril_group_id'], errors='ignore')\n                             .replace(0, np.nan)\n                             .dropna(how='any', axis=1)\n                             .columns.to_list())\n    l_col_info = exposure_data.get_input_fields('Loc')\n    gul_avail = {k: l_col_info[k.lower()][\"Type & Description\"] if k.lower() in l_col_info else desc_non_oed\n                 for k in set([c for c in l_col_list]).difference(int_excluded_cols)}\n\n    # IL perspective (join of acc + loc col with no dups)\n    il_avail = {}\n    if accounts_df is not None:\n        a_col_list = accounts_df.loc[:, ~accounts_df.isnull().all()].columns.to_list()\n        a_col_info = exposure_data.get_input_fields('Acc')\n        a_avail = set([c for c in a_col_list])\n        il_avail = {k: a_col_info[k.lower()][\"Type & Description\"] if k.lower() in a_col_info else desc_non_oed\n                    for k in a_avail.difference(gul_avail.keys())}\n\n    # Write JSON\n    gul_summary_lvl = {'GUL': {'available': {**gul_avail, **il_avail, **int_oasis_cols}}}\n    il_summary_lvl = {'IL': {'available': {**gul_avail, **il_avail, **int_oasis_cols}}} if il_avail else {}\n    with io.open(os.path.join(target_dir, 'exposure_summary_levels.json'), 'w', encoding='utf-8') as f:\n        f.write(json.dumps({**gul_summary_lvl, **il_summary_lvl}, sort_keys=True, ensure_ascii=False, indent=4))\n\n\"\"\"Docstring (excerpt)\"\"\"\nJson file with list Available / Recommended columns for use in the summary reporting\n\nAvailable: Columns which exists in input files and has at least one non-zero / NaN value\nRecommended: Columns which are available + also in the list of `useful` groupings SUMMARY_LEVEL_LOC\n\n{\n    'GUL': {\n        'available': ['AccNumber',\n                     'LocNumber',\n                     'istenant',\n                     'buildingid',\n                     'countrycode',\n                     'latitude',\n                     'longitude',\n                     'streetaddress',\n                     'postalcode',\n                     'occupancycode',\n                     'constructioncode',\n                     'locperilscovered',\n                     'BuildingTIV',\n                     'ContentsTIV',\n                     'BITIV',\n                     'PortNumber'],\n\n    'IL': {\n            ... etc ...\n    }\n}"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/preparation/summaries.py"], "intermediate_conclusion": "在 `oasislmf/preparation/summaries.py` 中找到 `write_summary_levels` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/preparation/summaries.py"], "intermediate_conclusion": "docstring 的首句可作为 `write_summary_levels` 职责的高置信摘要。"}], "output": "`write_summary_levels`（位于 `oasislmf/preparation/summaries.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Json file with list Available / Recommended columns for use in the summary reporting\n\n证据：该定义出现在文件 `oasislmf/preparation/summaries.py` 的第 248 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0152", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/execution/bash.py` 文件里的 `ord_enabled` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/execution/bash.py", "content": "# File: oasislmf/execution/bash.py\n# function: ord_enabled (lines 465-498)\n\ndef ord_enabled(summary_options, ORD_SWITCHES):\n    \"\"\"\n    Checks if ORD leccalc is enabled in a summaries section\n\n    :param summary_options: Summaies section from an analysis_settings file\n    :type summary_options: dict\n\n    :param ORD_SWITCHES: Options from the analysis_settings 'Summaies' section to search\n    :type  ORD_SWITCHES: dict\n\n    Example:\n    {\n        \"id\": 1,\n        \"ord_output\": {\n            \"ept_full_uncertainty_aep\": true,\n            \"ept_full_uncertainty_oep\": true,\n            \"ept_mean_sample_aep\": true,\n            \"ept_mean_sample_oep\": true,\n            \"ept_per_sample_mean_aep\": true,\n            \"ept_per_sample_mean_oep\": true,\n            \"psept_aep\": true,\n            \"psept_oep\": true,\n            \"return_period_file\": true\n        }\n    }\n\n    :return: True is leccalc is enables, False otherwise.\n    \"\"\"\n\n    ord_options = summary_options.get('ord_output', {})\n    for ouput_opt in ord_options:\n        if ouput_opt in ORD_SWITCHES and ord_options[ouput_opt]:\n            return True\n    return False\n\n\"\"\"Docstring (excerpt)\"\"\"\nChecks if ORD leccalc is enabled in a summaries section\n\n:param summary_options: Summaies section from an analysis_settings file\n:type summary_options: dict\n\n:param ORD_SWITCHES: Options from the analysis_settings 'Summaies' section to search\n:type  ORD_SWITCHES: dict\n\nExample:\n{\n    \"id\": 1,\n    \"ord_output\": {\n        \"ept_full_uncertainty_aep\": true,\n        \"ept_full_uncertainty_oep\": true,\n        \"ept_mean_sample_aep\": true,\n        \"ept_mean_sample_oep\": true,\n        \"ept_per_sample_mean_aep\": true,\n        \"ept_per_sample_mean_oep\": true,\n        \"psept_aep\": true,\n        \"psept_oep\": true,\n        \"return_period_file\": true\n    }\n}\n\n:return: True is leccalc is enables, False otherwise."}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/execution/bash.py"], "intermediate_conclusion": "在 `oasislmf/execution/bash.py` 中找到 `ord_enabled` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/execution/bash.py"], "intermediate_conclusion": "docstring 的首句可作为 `ord_enabled` 职责的高置信摘要。"}], "output": "`ord_enabled`（位于 `oasislmf/execution/bash.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Checks if ORD leccalc is enabled in a summaries section\n\n证据：该定义出现在文件 `oasislmf/execution/bash.py` 的第 465 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0023", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/execution/bin.py` 文件里的 `set_footprint_set` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/execution/bin.py", "content": "# File: oasislmf/execution/bin.py\n# function: set_footprint_set (lines 451-486)\n\ndef set_footprint_set(setting_val, run_dir):\n    \"\"\"\n    Create symbolic link to footprint file set that will be used for output\n    calculation.\n\n    :param setting_val: identifier for footprint set\n    :type setting_val: string\n\n    :param run_dir: model run directory\n    :type run_dir: string\n    \"\"\"\n    priorities = Footprint.get_footprint_fmt_priorities()\n    setting_val = str(setting_val)\n\n    for footprint_class in priorities:\n        for filename in footprint_class.footprint_filenames:\n            if '.' in filename:\n                stem, extension = filename.split('.', 1)\n                extension = '.' + extension\n            else:\n                stem = filename\n                extension = ''\n            footprint_fp = os.path.join(run_dir, 'static', f'{stem}_{setting_val}{extension}')\n            footprint_target_fp = os.path.join(run_dir, 'static', filename)\n            if not os.path.exists(footprint_fp):\n                # 'compatibility' - Fallback name formatting to keep existing conversion\n                setting_val_old = setting_val.replace(' ', '_').lower()\n                footprint_fp = os.path.join(run_dir, 'static', f'{stem}_{setting_val_old}{extension}')\n                if not os.path.exists(footprint_fp):\n                    logger.debug(f'{footprint_fp} not found, moving on to next footprint class')\n                    break\n            os.symlink(footprint_fp, footprint_target_fp)\n        else:\n            return\n\n    raise OasisException(f'Could not find footprint data files with identifier \"{setting_val}\"')\n\n\"\"\"Docstring (excerpt)\"\"\"\nCreate symbolic link to footprint file set that will be used for output\ncalculation.\n\n:param setting_val: identifier for footprint set\n:type setting_val: string\n\n:param run_dir: model run directory\n:type run_dir: string"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/execution/bin.py"], "intermediate_conclusion": "在 `oasislmf/execution/bin.py` 中找到 `set_footprint_set` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/execution/bin.py"], "intermediate_conclusion": "docstring 的首句可作为 `set_footprint_set` 职责的高置信摘要。"}], "output": "`set_footprint_set`（位于 `oasislmf/execution/bin.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Create symbolic link to footprint file set that will be used for output\n\n证据：该定义出现在文件 `oasislmf/execution/bin.py` 的第 451 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0140", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/pytools/fm/compute_sparse.py` 文件里的 `get_base_children` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/pytools/fm/compute_sparse.py", "content": "# File: oasislmf/pytools/fm/compute_sparse.py\n# function: get_base_children (lines 16-49)\n\ndef get_base_children(node, children, nodes_array, temp_children_queue):\n    \"\"\"\n    fill up temp_children_queue with all the base children of node from index 0 and return the number of base children\n    Args:\n        node: top node\n        children: array of all the children with loss value for each node\n        nodes_array: array of information on all nodes\n        temp_children_queue: empty array where we write base children.\n\n    Returns:\n        number of base children\n    \"\"\"\n    len_children = children[node['children']]\n    if len_children:\n        temp_children_queue[:len_children] = children[node['children'] + 1: node['children'] + len_children + 1]\n        temp_children_queue[len_children] = null_index\n        queue_end = len_children\n        i = 0\n        child_i = 0\n        while temp_children_queue[i] != null_index:\n            parent = nodes_array[temp_children_queue[i]]\n            len_children = children[parent['children']]\n            if len_children:\n                temp_children_queue[queue_end: queue_end + len_children] = children[parent['children'] + 1: parent['children'] + len_children + 1]\n                queue_end += len_children\n                temp_children_queue[queue_end] = null_index\n            else:\n                temp_children_queue[child_i] = temp_children_queue[i]\n                child_i += 1\n            i += 1\n    else:\n        temp_children_queue[0] = node['node_id']\n        child_i = 1\n    return child_i\n\n\"\"\"Docstring (excerpt)\"\"\"\nfill up temp_children_queue with all the base children of node from index 0 and return the number of base children\nArgs:\n    node: top node\n    children: array of all the children with loss value for each node\n    nodes_array: array of information on all nodes\n    temp_children_queue: empty array where we write base children.\n\nReturns:\n    number of base children"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/pytools/fm/compute_sparse.py"], "intermediate_conclusion": "在 `oasislmf/pytools/fm/compute_sparse.py` 中找到 `get_base_children` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/pytools/fm/compute_sparse.py"], "intermediate_conclusion": "docstring 的首句可作为 `get_base_children` 职责的高置信摘要。"}], "output": "`get_base_children`（位于 `oasislmf/pytools/fm/compute_sparse.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：fill up temp_children_queue with all the base children of node from index 0 and return the number of base children\n\n证据：该定义出现在文件 `oasislmf/pytools/fm/compute_sparse.py` 的第 16 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "fm", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "design_auto_0029", "task_type": "design", "instruction": "设计题：假设需要让 `GenerateExposurePreAnalysisCmd` 支持一种新的输入数据格式/字段，但要求不破坏现有调用方。请基于当前代码结构给出可实施的扩展方案，并指出可能修改的文件与位置。", "context": [{"source_type": "code", "path": "oasislmf/cli/model.py", "content": "# File: oasislmf/cli/model.py\n# class: GenerateExposurePreAnalysisCmd (lines 20-26)\n\nclass GenerateExposurePreAnalysisCmd(OasisComputationCommand):\n    \"\"\"\n    Generate a new EOD from original one by specifying a model specific pre-analysis hook for exposure modification\n    see ExposurePreAnalysis for more detail\n    \"\"\"\n    formatter_class = RawDescriptionHelpFormatter\n    computation_name = 'ExposurePreAnalysis'\n\n\"\"\"Docstring (excerpt)\"\"\"\nGenerate a new EOD from original one by specifying a model specific pre-analysis hook for exposure modification\nsee ExposurePreAnalysis for more detail"}], "reasoning_trace": [{"step": 1, "goal": "确认当前组件职责与边界", "evidence_ref": ["oasislmf/cli/model.py"], "intermediate_conclusion": "`GenerateExposurePreAnalysisCmd` 在 `oasislmf/cli/model.py` 中承担特定处理职责，应在其边界内扩展。"}, {"step": 2, "goal": "提出兼容性优先的扩展策略", "evidence_ref": ["oasislmf/cli/model.py"], "intermediate_conclusion": "通过适配层/解析函数新增支持，避免破坏现有契约与调用链。"}], "output": "基于 `oasislmf/cli/model.py` 中 `GenerateExposurePreAnalysisCmd` 的职责（见 docstring 与实现片段），在保持向后兼容的前提下可采用：\n1) 接口兼容：保留现有入参/返回契约，在内部引入“适配层/解析函数”处理新格式。\n2) 扩展点隔离：将新格式解析逻辑封装为独立函数/类，避免把分支逻辑散落在主流程。\n3) 渐进式切换：为新格式增加单测与示例；必要时在文档中声明支持范围。\n4) 修改位置：优先在 `oasislmf/cli/model.py` 的 `GenerateExposurePreAnalysisCmd` 定义附近（约第 20 行）扩展解析与分派逻辑；如存在调用链入口（CLI/管线），同步更新其输入校验与参数说明。\n", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_DESIGN", "difficulty": "medium", "language": "zh"}}
{"id": "design_auto_0047", "task_type": "design", "instruction": "设计题：假设需要让 `MyImport` 支持一种新的输入数据格式/字段，但要求不破坏现有调用方。请基于当前代码结构给出可实施的扩展方案，并指出可能修改的文件与位置。", "context": [{"source_type": "code", "path": "oasislmf/__init__.py", "content": "# File: oasislmf/__init__.py\n# class: MyImport (lines 33-68)\n\nclass MyImport(MetaPathFinder):\n    \"\"\" Support alias of depreciated sub-modules\n\n        * model_execution   -> execution\n        * model_preparation -> preparation\n        * api               -> platform\n\n        Example:\n            `from oasislmf.model_execution.bash import genbash`\n                is the same as calling the new name\n            `from oasislmf.execution.bash import genbash`\n            https://docs.python.org/3/library/importlib.html#importlib.machinery.PathFinder\n    \"\"\"\n\n    def __init__(self):\n        self.depricated_modules = {\n            \"model_execution\": \"execution\",\n            \"model_preparation\": \"preparation\",\n            \"api\": \"platform\",\n            \"platform\": \"platform_api\"\n        }\n\n    def find_spec(self, fullname, path=None, target=None):\n        import_path = fullname.split(\".\", 1)\n        if fullname.startswith(\"oasislmf\") and len(import_path) > 1:\n            import_path = import_path[1]\n            for deprecated in self.depricated_modules:\n                if deprecated == import_path or import_path.startswith(deprecated + '.'):\n                    with warnings.catch_warnings():\n                        warnings.simplefilter(\"always\")\n                        warnings.warn(\n                            f\"imports from 'oasislmf.{deprecated}' are deprecated. Import by using 'oasislmf.{self.depricated_modules[deprecated]}' instead.\"\n                        )\n                    import_path = import_path.replace(deprecated, self.depricated_modules[deprecated])\n\n            return spec_from_loader(fullname, MyLoader(import_path))\n\n\"\"\"Docstring (excerpt)\"\"\"\nSupport alias of depreciated sub-modules\n\n* model_execution   -> execution\n* model_preparation -> preparation\n* api               -> platform\n\nExample:\n    `from oasislmf.model_execution.bash import genbash`\n        is the same as calling the new name\n    `from oasislmf.execution.bash import genbash`\n    https://docs.python.org/3/library/importlib.html#importlib.machinery.PathFinder"}], "reasoning_trace": [{"step": 1, "goal": "确认当前组件职责与边界", "evidence_ref": ["oasislmf/__init__.py"], "intermediate_conclusion": "`MyImport` 在 `oasislmf/__init__.py` 中承担特定处理职责，应在其边界内扩展。"}, {"step": 2, "goal": "提出兼容性优先的扩展策略", "evidence_ref": ["oasislmf/__init__.py"], "intermediate_conclusion": "通过适配层/解析函数新增支持，避免破坏现有契约与调用链。"}], "output": "基于 `oasislmf/__init__.py` 中 `MyImport` 的职责（见 docstring 与实现片段），在保持向后兼容的前提下可采用：\n1) 接口兼容：保留现有入参/返回契约，在内部引入“适配层/解析函数”处理新格式。\n2) 扩展点隔离：将新格式解析逻辑封装为独立函数/类，避免把分支逻辑散落在主流程。\n3) 渐进式切换：为新格式增加单测与示例；必要时在文档中声明支持范围。\n4) 修改位置：优先在 `oasislmf/__init__.py` 的 `MyImport` 定义附近（约第 33 行）扩展解析与分派逻辑；如存在调用链入口（CLI/管线），同步更新其输入校验与参数说明。\n", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_DESIGN", "difficulty": "medium", "language": "zh"}}
{"id": "qa_auto_0174", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/pytools/getmodel/manager.py` 文件里的 `load_vulns_bin` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/pytools/getmodel/manager.py", "content": "# File: oasislmf/pytools/getmodel/manager.py\n# function: load_vulns_bin (lines 316-344)\n\ndef load_vulns_bin(vulns_bin, vuln_dict, num_damage_bins, num_intensity_bins):\n    \"\"\"\n    Loads the vulnerability data grouped by the intensity and damage bins.\n\n    Args:\n        vuln_bin: (List[Vulnerability]) vulnerability data from the vulnerability file\n        vuln_dict: (Dict[int, int]) maps the vulnerability ID with the index in the vulnerability array\n        num_damage_bins: (int) number of damage bins in the data\n        num_intensity_bins: (int) the number of intensity bins\n\n    Returns: (List[List[List[floats]]]) vulnerability data grouped by intensity bin and damage bin\n    \"\"\"\n    vuln_array = np.zeros((len(vuln_dict), num_damage_bins, num_intensity_bins), dtype=oasis_float)\n    vuln_ids = np.full(len(vuln_dict), null_index)\n    cur_vulnerability_id = -1\n\n    for vuln_i in range(vulns_bin.shape[0]):\n        vuln = vulns_bin[vuln_i]\n        if vuln['vulnerability_id'] != cur_vulnerability_id:\n            if vuln['vulnerability_id'] in vuln_dict:\n                cur_vulnerability_id = vuln['vulnerability_id']\n                vuln_ids[vuln_dict[cur_vulnerability_id]] = cur_vulnerability_id\n                cur_vuln_array = vuln_array[vuln_dict[cur_vulnerability_id]]\n            else:\n                cur_vulnerability_id = -1\n        if cur_vulnerability_id != -1:\n            load_vuln_probability(cur_vuln_array, vuln, cur_vulnerability_id)\n\n    return vuln_array, vuln_ids\n\n\"\"\"Docstring (excerpt)\"\"\"\nLoads the vulnerability data grouped by the intensity and damage bins.\n\nArgs:\n    vuln_bin: (List[Vulnerability]) vulnerability data from the vulnerability file\n    vuln_dict: (Dict[int, int]) maps the vulnerability ID with the index in the vulnerability array\n    num_damage_bins: (int) number of damage bins in the data\n    num_intensity_bins: (int) the number of intensity bins\n\nReturns: (List[List[List[floats]]]) vulnerability data grouped by intensity bin and damage bin"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/pytools/getmodel/manager.py"], "intermediate_conclusion": "在 `oasislmf/pytools/getmodel/manager.py` 中找到 `load_vulns_bin` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/pytools/getmodel/manager.py"], "intermediate_conclusion": "docstring 的首句可作为 `load_vulns_bin` 职责的高置信摘要。"}], "output": "`load_vulns_bin`（位于 `oasislmf/pytools/getmodel/manager.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Loads the vulnerability data grouped by the intensity and damage bins.\n\n证据：该定义出现在文件 `oasislmf/pytools/getmodel/manager.py` 的第 316 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0027", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/pytools/gulmc/manager.py` 文件里的 `process_areaperils_in_footprint` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/pytools/gulmc/manager.py", "content": "# File: oasislmf/pytools/gulmc/manager.py\n# function: process_areaperils_in_footprint (lines 1041-1115)\n\ndef process_areaperils_in_footprint(event_footprint,\n                                    present_areaperils,\n                                    dynamic_footprint):\n    \"\"\"\n    Process all the areaperils in the footprint, filtering and retaining only those who have associated vulnerability functions\n\n    Args:\n        event_footprint (np.array[Event or footprint_event_dtype]): footprint, made of one or more event entries.\n        present_areaperils (dict[int, int]): areaperil to vulnerability index dictionary.\n        dynamic_footprint (boolean): true if there is dynamic_footprint\n\n    Returns:\n        areaperil_ids (List[int]): list of all areaperil_ids present in the footprint.\n        Nhaz_arr_this_event (int): number of hazard stored for this event. If zero, it means no items have losses in such event.\n        areaperil_to_haz_arr_i (dict[int, int]): map between the areaperil_id and the hazard index in haz_arr_ptr.\n        haz_pdf (np.array[oasis_float]): hazard intensity pdf.\n        haz_arr_ptr (np.array[int]): array with the indices where each hazard intensities record starts in haz arrays (ie, haz_pdf).\n    \"\"\"\n    # init data structures\n    haz_prob_start_in_footprint = List.empty_list(nb_int64)\n    areaperil_ids = List.empty_list(nb_areaperil_int)\n\n    footprint_i = 0\n    last_areaperil_id = nb_areaperil_int(0)\n    last_areaperil_id_start = nb_int64(0)\n    haz_arr_i = 0\n    areaperil_to_haz_arr_i = Dict.empty(nb_areaperil_int, nb_oasis_int)\n\n    Nevent_footprint_entries = len(event_footprint)\n    haz_pdf = np.empty(Nevent_footprint_entries, dtype=haz_arr_type)  # max size\n\n    arr_ptr_start = 0\n    arr_ptr_end = 0\n    haz_arr_ptr = List([0])\n\n    while footprint_i <= Nevent_footprint_entries:\n\n        if footprint_i < Nevent_footprint_entries:\n            areaperil_id = event_footprint[footprint_i]['areaperil_id']\n        else:\n            areaperil_id = nb_areaperil_int(0)\n\n        if areaperil_id != last_areaperil_id:\n            # one areaperil_id is completed\n\n            if last_areaperil_id > 0:\n                if last_areaperil_id in present_areaperils:\n                    # if items with this areaperil_id exist, process and store this areaperil_id\n                    areaperil_ids.append(last_areaperil_id)\n                    haz_prob_start_in_footprint.append(last_areaperil_id_start)\n                    areaperil_to_haz_arr_i[last_areaperil_id] = nb_int32(haz_arr_i)\n                    haz_arr_i += 1\n\n                    # store the hazard intensity pdf\n                    arr_ptr_end = arr_ptr_start + (footprint_i - last_areaperil_id_start)\n                    haz_pdf['probability'][arr_ptr_start: arr_ptr_end] = event_footprint['probability'][last_areaperil_id_start: footprint_i]\n                    haz_pdf['intensity_bin_id'][arr_ptr_start: arr_ptr_end] = event_footprint['intensity_bin_id'][last_areaperil_id_start: footprint_i]\n                    if dynamic_footprint is not None:\n                        haz_pdf['intensity'][arr_ptr_start: arr_ptr_end] = event_footprint['intensity'][last_areaperil_id_start: footprint_i]\n\n                    haz_arr_ptr.append(arr_ptr_end)\n                    arr_ptr_start = arr_ptr_end\n\n            last_areaperil_id = areaperil_id\n            last_areaperil_id_start = footprint_i\n\n        footprint_i += 1\n\n    Nhaz_arr_this_event = haz_arr_i\n\n    return (areaperil_ids,\n            Nhaz_arr_this_event,\n            areaperil_to_haz_arr_i,\n            haz_pdf[:arr_ptr_end],\n            haz_arr_ptr)\n\n\"\"\"Docstring (excerpt)\"\"\"\nProcess all the areaperils in the footprint, filtering and retaining only those who have associated vulnerability functions\n\nArgs:\n    event_footprint (np.array[Event or footprint_event_dtype]): footprint, made of one or more event entries.\n    present_areaperils (dict[int, int]): areaperil to vulnerability index dictionary.\n    dynamic_footprint (boolean): true if there is dynamic_footprint\n\nReturns:\n    areaperil_ids (List[int]): list of all areaperil_ids present in the footprint.\n    Nhaz_arr_this_event (int): number of hazard stored for this event. If zero, it means no items have losses in such event.\n    areaperil_to_haz_arr_i (dict[int, int]): map between the areaperil_id and the hazard index in haz_arr_ptr.\n    haz_pdf (np.array[oasis_float]): hazard intensity pdf.\n    haz_arr_ptr (np.array[int]): array with the indices where each hazard intensities record starts in haz arrays (ie, haz_pdf)."}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/pytools/gulmc/manager.py"], "intermediate_conclusion": "在 `oasislmf/pytools/gulmc/manager.py` 中找到 `process_areaperils_in_footprint` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/pytools/gulmc/manager.py"], "intermediate_conclusion": "docstring 的首句可作为 `process_areaperils_in_footprint` 职责的高置信摘要。"}], "output": "`process_areaperils_in_footprint`（位于 `oasislmf/pytools/gulmc/manager.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Process all the areaperils in the footprint, filtering and retaining only those who have associated vulnerability functions\n\n证据：该定义出现在文件 `oasislmf/pytools/gulmc/manager.py` 的第 1041 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "gul", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0189", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/platform_api/client.py` 文件里的 `ApiEndpoint` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/platform_api/client.py", "content": "# File: oasislmf/platform_api/client.py\n# class: ApiEndpoint (lines 32-61)\n\nclass ApiEndpoint(object):\n    \"\"\"\n    Used to Implement the default requests common to all Oasis API\n    End points.\n    \"\"\"\n\n    def __init__(self, session, url_endpoint, logger=None):\n        self.logger = logger or logging.getLogger(__name__)\n        self.session = session\n        self.url_endpoint = str(url_endpoint)\n\n    def create(self, data):\n        return self.session.post(self.url_endpoint, json=data)\n\n    def get(self, ID=None):\n        if ID:\n            return self.session.get(urljoin(self.url_endpoint, f'{ID}/'))\n        return self.session.get(self.url_endpoint)\n\n    def delete(self, ID):\n        return self.session.delete(urljoin(self.url_endpoint, f'{ID}/'))\n\n    def search(self, metadata={}):\n        search_string = \"\"\n        for key in metadata:\n            if not search_string:\n                search_string = f'?{key}={metadata[key]}'\n            else:\n                search_string += f'&{key}={metadata[key]}'\n        return self.session.get(f'{self.url_endpoint}{search_string}')\n\n\"\"\"Docstring (excerpt)\"\"\"\nUsed to Implement the default requests common to all Oasis API\nEnd points."}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/platform_api/client.py"], "intermediate_conclusion": "在 `oasislmf/platform_api/client.py` 中找到 `ApiEndpoint` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/platform_api/client.py"], "intermediate_conclusion": "docstring 的首句可作为 `ApiEndpoint` 职责的高置信摘要。"}], "output": "`ApiEndpoint`（位于 `oasislmf/platform_api/client.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Used to Implement the default requests common to all Oasis API\n\n证据：该定义出现在文件 `oasislmf/platform_api/client.py` 的第 32 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0036", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/pytools/getmodel/manager.py` 文件里的 `load_vulns_bin_adjusted` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/pytools/getmodel/manager.py", "content": "# File: oasislmf/pytools/getmodel/manager.py\n# function: load_vulns_bin_adjusted (lines 348-395)\n\ndef load_vulns_bin_adjusted(vulns_bin, vuln_dict, num_damage_bins, num_intensity_bins, adj_vuln_data=None):\n    \"\"\"\n    Loads the vulnerability data grouped by the intensity and damage bins, prioritizing the data\n    in the adjustments file over the data in the vulnerability file.\n\n    Args:\n        vuln_bin: (List[Vulnerability]) vulnerability data from the vulnerability file\n        vuln_dict: (Dict[int, int]) maps the vulnerability ID with the index in the vulnerability array\n        num_damage_bins: (int) number of damage bins in the data\n        num_intensity_bins: (int) the number of intensity bins\n        adj_vuln_data: (List[vulnerability_dtype]) vulnerability adjustment data, sorted by vuln_id\n\n    Returns: (List[List[List[floats]]]) vulnerability data grouped by intensity bin and damage bin\n    \"\"\"\n    vuln_array = np.zeros((len(vuln_dict), num_damage_bins, num_intensity_bins), dtype=oasis_float)\n    vuln_ids = np.full(len(vuln_dict), null_index)\n    ids_to_replace = set()\n    adj_vuln_index = 0\n\n    # Create list of ids to replace if adj_vuln_data is provided\n    if adj_vuln_data is not None:\n        for adj_vuln in adj_vuln_data:\n            ids_to_replace.add(adj_vuln['vulnerability_id'])\n\n    vuln_i = 0\n\n    while vuln_i < len(vulns_bin):\n        vuln = vulns_bin[vuln_i]\n        vuln_id = vuln['vulnerability_id']\n        if vuln_id in vuln_dict:\n            vuln_ids[vuln_dict[vuln_id]] = vuln_id\n            if vuln_id in ids_to_replace:\n                # Advance to current vuln_id\n                while adj_vuln_index < len(adj_vuln_data) and adj_vuln_data[adj_vuln_index]['vulnerability_id'] < vuln_id:\n                    adj_vuln_index += 1\n                # process current vuln_id\n                while adj_vuln_index < len(adj_vuln_data) and adj_vuln_data[adj_vuln_index]['vulnerability_id'] == vuln_id:\n                    load_vuln_probability(vuln_array[vuln_dict[vuln_id]], adj_vuln_data[adj_vuln_index], vuln_id)\n                    adj_vuln_index += 1\n                # Skip remaining vulns_bin entries with the same vulnerability_id\n                while vuln_i < len(vulns_bin) and vulns_bin[vuln_i]['vulnerability_id'] == vuln_id:\n                    vuln_i += 1\n                continue\n            else:\n                # Use data from vulns_bin\n                load_vuln_probability(vuln_array[vuln_dict[vuln_id]], vuln, vuln_id)\n        vuln_i += 1\n    return vuln_array, vuln_ids\n\n\"\"\"Docstring (excerpt)\"\"\"\nLoads the vulnerability data grouped by the intensity and damage bins, prioritizing the data\nin the adjustments file over the data in the vulnerability file.\n\nArgs:\n    vuln_bin: (List[Vulnerability]) vulnerability data from the vulnerability file\n    vuln_dict: (Dict[int, int]) maps the vulnerability ID with the index in the vulnerability array\n    num_damage_bins: (int) number of damage bins in the data\n    num_intensity_bins: (int) the number of intensity bins\n    adj_vuln_data: (List[vulnerability_dtype]) vulnerability adjustment data, sorted by vuln_id\n\nReturns: (List[List[List[floats]]]) vulnerability data grouped by intensity bin and damage bin"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/pytools/getmodel/manager.py"], "intermediate_conclusion": "在 `oasislmf/pytools/getmodel/manager.py` 中找到 `load_vulns_bin_adjusted` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/pytools/getmodel/manager.py"], "intermediate_conclusion": "docstring 的首句可作为 `load_vulns_bin_adjusted` 职责的高置信摘要。"}], "output": "`load_vulns_bin_adjusted`（位于 `oasislmf/pytools/getmodel/manager.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Loads the vulnerability data grouped by the intensity and damage bins, prioritizing the data\n\n证据：该定义出现在文件 `oasislmf/pytools/getmodel/manager.py` 的第 348 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0058", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/computation/run/generate_losses.py` 文件里的 `GenerateOasisLosses` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/computation/run/generate_losses.py", "content": "# File: oasislmf/computation/run/generate_losses.py\n# class: GenerateOasisLosses (lines 14-54)\n\nclass GenerateOasisLosses(ComputationStep):\n    \"\"\"\n    Run Oasis file geneartion with optional PreAnalysis hook.\n    \"\"\"\n\n    # Override params\n    step_params = [\n        {'name': 'pre_loss_module', 'required': False, 'is_path': True, 'pre_exist': True,\n         'help': 'Pre-Loss module path'},\n        {'name': 'post_analysis_module', 'required': False, 'is_path': True, 'pre_exist': True,\n         'help': 'Post-Analysis module path'},\n    ]\n    # Add params from each sub command not in 'step_params'\n    chained_commands = [\n        PreLoss,\n        GenerateLosses,\n        PostAnalysis,\n    ]\n\n    def run(self):\n\n        # setup output dir\n        if not self.model_run_dir:\n            self.model_run_dir = GenerateLosses._get_output_dir(self)\n        self.kwargs['model_run_dir'] = self.model_run_dir\n\n        # Run chain\n        if self.pre_loss_module:\n            cmds = [(PreLoss, self.kwargs)]\n        else:\n            cmds = []\n        cmds += [(GenerateLosses, self.kwargs)]\n        if self.post_analysis_module:\n            cmds += [(PostAnalysis, self.kwargs)]\n\n        with tqdm(total=len(cmds)) as pbar:\n            for cmd in cmds:\n                cmd[0](**cmd[1]).run()\n                pbar.update(1)\n\n        self.logger.info(f'Losses generated in {self.model_run_dir}')\n\n\"\"\"Docstring (excerpt)\"\"\"\nRun Oasis file geneartion with optional PreAnalysis hook."}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/computation/run/generate_losses.py"], "intermediate_conclusion": "在 `oasislmf/computation/run/generate_losses.py` 中找到 `GenerateOasisLosses` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/computation/run/generate_losses.py"], "intermediate_conclusion": "docstring 的首句可作为 `GenerateOasisLosses` 职责的高置信摘要。"}], "output": "`GenerateOasisLosses`（位于 `oasislmf/computation/run/generate_losses.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Run Oasis file geneartion with optional PreAnalysis hook.\n\n证据：该定义出现在文件 `oasislmf/computation/run/generate_losses.py` 的第 14 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "gul", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0063", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/utils/data.py` 文件里的 `detect_encoding` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/utils/data.py", "content": "# File: oasislmf/utils/data.py\n# function: detect_encoding (lines 325-344)\n\ndef detect_encoding(filepath):\n    \"\"\"\n    Given a path to a CSV of unknown encoding\n    read lines to detects its encoding type\n\n    :param filepath: Filepath to check\n    :type  filepath: str\n\n    :return: Example `{'encoding': 'ISO-8859-1', 'confidence': 0.73, 'language': ''}`\n    :rtype: dict\n    \"\"\"\n\n    detector = UniversalDetector()\n    with io.open(filepath, 'rb') as f:\n        for line in f:\n            detector.feed(line)\n            if detector.done:\n                break\n    detector.close()\n    return detector.result\n\n\"\"\"Docstring (excerpt)\"\"\"\nGiven a path to a CSV of unknown encoding\nread lines to detects its encoding type\n\n:param filepath: Filepath to check\n:type  filepath: str\n\n:return: Example `{'encoding': 'ISO-8859-1', 'confidence': 0.73, 'language': ''}`\n:rtype: dict"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/utils/data.py"], "intermediate_conclusion": "在 `oasislmf/utils/data.py` 中找到 `detect_encoding` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/utils/data.py"], "intermediate_conclusion": "docstring 的首句可作为 `detect_encoding` 职责的高置信摘要。"}], "output": "`detect_encoding`（位于 `oasislmf/utils/data.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Given a path to a CSV of unknown encoding\n\n证据：该定义出现在文件 `oasislmf/utils/data.py` 的第 325 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0071", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/pytools/lec/aggreports/write_tables.py` 文件里的 `write_tvar_wheatsheaf` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/pytools/lec/aggreports/write_tables.py", "content": "# File: oasislmf/pytools/lec/aggreports/write_tables.py\n# function: write_tvar_wheatsheaf (lines 247-268)\n\ndef write_tvar_wheatsheaf(\n    num_sidxs,\n    eptype_tvar,\n    tail,\n    tail_sizes,\n):\n    \"\"\"Get TVaR values for PSEPT output from tail\n    Args:\n        num_sidxs (int): Number of sidxs to consider.\n        eptype_tvar (int): Type of Tail Value-at-Risk (TVAR) to calculate (0 = OEP TVAR, 1 = AEP TVAR).\n        tail (nb.typed.Dict[nb_oasis_int, NB_TAIL_valtype]): Dict of (summary_id, sidx) pair to vector of (return period, tvar) values\n        tail_sizes (nb.typed.Dict[nb_oasis_int, nb.types.int64]): Dict of (summary_id, sidx) pair to size of each tail array\n    Returns:\n        rets (list[PSEPT_dtype]): Return period and Loss PSEPT data\n    \"\"\"\n    rets = []\n    for idx in sorted(tail.keys()):\n        sidx, summary_id = get_wheatsheaf_items_idx_data(idx, num_sidxs)\n        vals = tail[idx][:tail_sizes[idx]]\n        for row in vals:\n            rets.append((summary_id, sidx, eptype_tvar, row[\"retperiod\"], row[\"tvar\"]))\n    return rets\n\n\"\"\"Docstring (excerpt)\"\"\"\nGet TVaR values for PSEPT output from tail\nArgs:\n    num_sidxs (int): Number of sidxs to consider.\n    eptype_tvar (int): Type of Tail Value-at-Risk (TVAR) to calculate (0 = OEP TVAR, 1 = AEP TVAR).\n    tail (nb.typed.Dict[nb_oasis_int, NB_TAIL_valtype]): Dict of (summary_id, sidx) pair to vector of (return period, tvar) values\n    tail_sizes (nb.typed.Dict[nb_oasis_int, nb.types.int64]): Dict of (summary_id, sidx) pair to size of each tail array\nReturns:\n    rets (list[PSEPT_dtype]): Return period and Loss PSEPT data"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/pytools/lec/aggreports/write_tables.py"], "intermediate_conclusion": "在 `oasislmf/pytools/lec/aggreports/write_tables.py` 中找到 `write_tvar_wheatsheaf` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/pytools/lec/aggreports/write_tables.py"], "intermediate_conclusion": "docstring 的首句可作为 `write_tvar_wheatsheaf` 职责的高置信摘要。"}], "output": "`write_tvar_wheatsheaf`（位于 `oasislmf/pytools/lec/aggreports/write_tables.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Get TVaR values for PSEPT output from tail\n\n证据：该定义出现在文件 `oasislmf/pytools/lec/aggreports/write_tables.py` 的第 247 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "aggregation", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0190", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/computation/data/dummy_model/generate.py` 文件里的 `generate_data` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/computation/data/dummy_model/generate.py", "content": "# File: oasislmf/computation/data/dummy_model/generate.py\n# function: generate_data (lines 988-1015)\n\n    def generate_data(self):\n        \"\"\"\n        Generate Financial Model Policy dummy model file data.\n\n        Yields:\n            level (int): level ID.\n            agg_id (int): aggregate ID.\n            layer (int): layer ID.\n            profile_id (int): profile ID.\n        \"\"\"\n        # Site coverage #1 & policy layer #10 FM levels\n        levels = [1, 10]\n        levels = range(1, len(levels) + 1)\n        profile_id = 1\n        for level in levels:\n            # Site coverage FM level\n            if level == 1:\n                for agg_id in range(\n                    1, self.num_locations * self.coverages_per_location + 1\n                ):\n                    # One layer in site coverage FM level\n                    yield level, agg_id, 1, profile_id\n                profile_id += 1   # Next profile_id\n            # Policy layer FM level\n            elif level == len(levels):\n                for layer in range(self.num_layers):\n                    yield level, 1, layer + 1, profile_id\n                    profile_id += 1   # Next profile_id\n\n\"\"\"Docstring (excerpt)\"\"\"\nGenerate Financial Model Policy dummy model file data.\n\nYields:\n    level (int): level ID.\n    agg_id (int): aggregate ID.\n    layer (int): layer ID.\n    profile_id (int): profile ID."}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/computation/data/dummy_model/generate.py"], "intermediate_conclusion": "在 `oasislmf/computation/data/dummy_model/generate.py` 中找到 `generate_data` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/computation/data/dummy_model/generate.py"], "intermediate_conclusion": "docstring 的首句可作为 `generate_data` 职责的高置信摘要。"}], "output": "`generate_data`（位于 `oasislmf/computation/data/dummy_model/generate.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Generate Financial Model Policy dummy model file data.\n\n证据：该定义出现在文件 `oasislmf/computation/data/dummy_model/generate.py` 的第 988 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0007", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/utils/documentation/jsontomd/base.py` 文件里的 `BaseJsonToMarkdownGenerator` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/utils/documentation/jsontomd/base.py", "content": "# File: oasislmf/utils/documentation/jsontomd/base.py\n# class: BaseJsonToMarkdownGenerator (lines 6-48)\n\nclass BaseJsonToMarkdownGenerator(ABC):\n    \"\"\"\n    Base JSON to Markdown Generator class\n    \"\"\"\n\n    def __init__(self, full_schema, data_path, doc_out_dir, markdown_generator=None):\n        \"\"\"\n        Args:\n            full_schema (Dict): Full schema file as dictionary\n            data_path (str | os.PathLike): Path to data folder for any relative file paths\n            doc_out_dir (str | os.PathLike): Path to documentation file output folder for any relative file paths\n            markdown_generator (MarkdownGenerator, optional): MarkdownGenerator class. Defaults to None.\n        \"\"\"\n        self.full_schema = full_schema\n        self.data_path = data_path\n        self.doc_out_dir = doc_out_dir\n        self.md = markdown_generator\n        if not markdown_generator:\n            self.md = MarkdownGenerator()\n\n    def _resolve_internal_ref(self, ref):\n        \"\"\"Resolves a $ref in the schema (only internal refs supported).\n        Args:\n            ref (str): Reference string of format #/$<reftitle>/<refname>\n        Returns:\n            ref_schema (Dict): Data Properties from reference schema as dictionary\n        \"\"\"\n        parts = ref.strip(\"#/\").split(\"/\")\n        ref_schema = self.full_schema\n        for part in parts:\n            ref_schema = ref_schema.get(part, {})\n        return ref_schema\n\n    @abstractmethod\n    def generate(self, json_data, generate_toc=False):\n        \"\"\"Top level function to process entire dict to markdown text\n        Args:\n            json_data (Dict): Json data as dictionary\n            generate_toc (bool, Optional): Generate table of contents bool. Defaults to False.\n        Returns:\n            markdown_txt (str): Markdown text\n        \"\"\"\n        pass\n\n\"\"\"Docstring (excerpt)\"\"\"\nBase JSON to Markdown Generator class"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/utils/documentation/jsontomd/base.py"], "intermediate_conclusion": "在 `oasislmf/utils/documentation/jsontomd/base.py` 中找到 `BaseJsonToMarkdownGenerator` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/utils/documentation/jsontomd/base.py"], "intermediate_conclusion": "docstring 的首句可作为 `BaseJsonToMarkdownGenerator` 职责的高置信摘要。"}], "output": "`BaseJsonToMarkdownGenerator`（位于 `oasislmf/utils/documentation/jsontomd/base.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Base JSON to Markdown Generator class\n\n证据：该定义出现在文件 `oasislmf/utils/documentation/jsontomd/base.py` 的第 6 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0029", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/computation/generate/files.py` 文件里的 `GenerateDummyOasisFiles` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/computation/generate/files.py", "content": "# File: oasislmf/computation/generate/files.py\n# class: GenerateDummyOasisFiles (lines 576-657)\n\nclass GenerateDummyOasisFiles(GenerateDummyModelFiles):\n    \"\"\"\n    Generates dummy model and Oasis GUL input files + optionally the IL/FM\n    input files.\n    \"\"\"\n\n    step_params = [\n        {'name': 'num_locations', 'flag': '-l', 'required': True, 'type': int, 'help': 'Number of locations'},\n        {'name': 'coverages_per_location', 'flag': '-c', 'required': True, 'type': int, 'help': 'Number of coverage types per location'},\n        {'name': 'num_layers', 'required': False, 'type': int, 'default': 1, 'help': 'Number of layers'}\n    ]\n    chained_commands = [GenerateDummyModelFiles]\n\n    def _validate_input_arguments(self):\n        super()._validate_input_arguments()\n        if self.coverages_per_location > 4 or self.coverages_per_location < 1:\n            raise OasisException('Number of supported coverage types is 1 to 4')\n\n    def _get_gul_file_objects(self):\n\n        # coverages.bin, items.bin and gulsummaryxref.bin\n        self.gul_files = [\n            CoveragesFile(\n                self.num_locations, self.coverages_per_location,\n                self.random_seed, self.input_dir\n            ),\n            ItemsFile(\n                self.num_locations, self.coverages_per_location,\n                self.num_areaperils, self.num_vulnerabilities,\n                self.random_seed, self.input_dir\n            ),\n            GULSummaryXrefFile(\n                self.num_locations, self.coverages_per_location, self.input_dir\n            )\n        ]\n        if self.num_amplifications > 0:\n            self.gul_files += [\n                AmplificationsFile(\n                    self.num_locations, self.coverages_per_location,\n                    self.num_amplifications, self.random_seed, self.input_dir\n                )\n            ]\n\n    def _get_fm_file_objects(self):\n\n        # fm_programme.bin, fm_policytc.bin, fm_profile.bin, fm_xref.bin and\n        # fmsummaryxref.bin\n        self.fm_files = [\n            FMProgrammeFile(\n                self.num_locations, self.coverages_per_location, self.input_dir\n            ),\n            FMPolicyTCFile(\n                self.num_locations, self.coverages_per_location,\n                self.num_layers, self.input_dir\n            ),\n            FMProfileFile(self.num_layers, self.input_dir),\n            FMXrefFile(\n                self.num_locations, self.coverages_per_location,\n                self.num_layers, self.input_dir\n            ),\n            FMSummaryXrefFile(\n                self.num_locations, self.coverages_per_location,\n                self.num_layers, self.input_dir\n            )\n        ]\n\n    def run(self):\n        self.logger.info('\\nProcessing arguments - Creating Model & Test Oasis Files')\n\n        self._validate_input_arguments()\n        self._create_target_directory(label='files')\n        self._prepare_run_directory()\n        self._get_model_file_objects()\n        self._get_gul_file_objects()\n        self._get_fm_file_objects()\n\n        output_files = self.model_files + self.gul_files + self.fm_files\n        for output_file in output_files:\n            self.logger.info(f'Writing {output_file.file_name}')\n            output_file.write_file()\n\n\"\"\"Docstring (excerpt)\"\"\"\nGenerates dummy model and Oasis GUL input files + optionally the IL/FM\ninput files."}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/computation/generate/files.py"], "intermediate_conclusion": "在 `oasislmf/computation/generate/files.py` 中找到 `GenerateDummyOasisFiles` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/computation/generate/files.py"], "intermediate_conclusion": "docstring 的首句可作为 `GenerateDummyOasisFiles` 职责的高置信摘要。"}], "output": "`GenerateDummyOasisFiles`（位于 `oasislmf/computation/generate/files.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：Generates dummy model and Oasis GUL input files + optionally the IL/FM\n\n证据：该定义出现在文件 `oasislmf/computation/generate/files.py` 的第 576 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "other", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
{"id": "qa_auto_0164", "task_type": "qa", "instruction": "在 OasisLMF 项目中，`oasislmf/pytools/gulmc/manager.py` 文件里的 `calc_eff_damage_cdf` 主要负责什么功能？请根据代码与文档注释回答。", "context": [{"source_type": "code", "path": "oasislmf/pytools/gulmc/manager.py", "content": "# File: oasislmf/pytools/gulmc/manager.py\n# function: calc_eff_damage_cdf (lines 660-681)\n\ndef calc_eff_damage_cdf(vuln_pdf, haz_pdf, eff_damage_cdf_empty):\n    \"\"\"\n    calculate the covoluted cumulative distribution between vulnerability damage and hazard probability distribution\n    Args:\n        vuln_pdf (np.array[float]) : vulnerability damage probability distribution\n        haz_pdf (np.array[float]): hazard probability distribution\n        eff_damage_cdf_empty (np.array[float]): output buffer\n    Returns:\n        eff_damage_cdf (np.array[float]): cdf is stored in eff_damage_cdf_empty, here we return only the valid part if needed\n    \"\"\"\n    eff_damage_cdf_cumsum = 0.\n    damage_bin_i = 0\n    while damage_bin_i < vuln_pdf.shape[1]:\n        for haz_i in range(vuln_pdf.shape[0]):\n            eff_damage_cdf_cumsum += vuln_pdf[haz_i, damage_bin_i] * haz_pdf[haz_i]\n\n        eff_damage_cdf_empty[damage_bin_i] = eff_damage_cdf_cumsum\n        damage_bin_i += 1\n        if eff_damage_cdf_cumsum >= 0.999999940:\n            break\n    damage_bin_i = get_last_non_empty(eff_damage_cdf_empty, damage_bin_i - 1)\n    return eff_damage_cdf_empty[:damage_bin_i + 1]\n\n\"\"\"Docstring (excerpt)\"\"\"\ncalculate the covoluted cumulative distribution between vulnerability damage and hazard probability distribution\nArgs:\n    vuln_pdf (np.array[float]) : vulnerability damage probability distribution\n    haz_pdf (np.array[float]): hazard probability distribution\n    eff_damage_cdf_empty (np.array[float]): output buffer\nReturns:\n    eff_damage_cdf (np.array[float]): cdf is stored in eff_damage_cdf_empty, here we return only the valid part if needed"}], "reasoning_trace": [{"step": 1, "goal": "定位目标符号的定义与职责描述", "evidence_ref": ["oasislmf/pytools/gulmc/manager.py"], "intermediate_conclusion": "在 `oasislmf/pytools/gulmc/manager.py` 中找到 `calc_eff_damage_cdf` 的定义及 docstring。"}, {"step": 2, "goal": "基于 docstring/实现总结其主要功能", "evidence_ref": ["oasislmf/pytools/gulmc/manager.py"], "intermediate_conclusion": "docstring 的首句可作为 `calc_eff_damage_cdf` 职责的高置信摘要。"}], "output": "`calc_eff_damage_cdf`（位于 `oasislmf/pytools/gulmc/manager.py`）的主要职责可以从其 docstring 与实现片段看出：\n- 核心描述：calculate the covoluted cumulative distribution between vulnerability damage and hazard probability distribution\n\n证据：该定义出现在文件 `oasislmf/pytools/gulmc/manager.py` 的第 660 行附近。", "metadata": {"repo": "OasisLMF", "business_stage": "gul", "question_id": "AUTO_FACT", "difficulty": "easy", "language": "zh"}}
